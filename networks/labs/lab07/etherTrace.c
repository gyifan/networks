/*
 * Copyright (c) 2012 Bucknell University
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Author: L. Felipe Perrone (perrone@bucknell.edu)
 */

/*
 * This is a skeleton program for analyzing Ethernet packet traces
 * generated by 'wireshark', or 'tcpdump.'
 *
 * Revised by Xiannong Meng for CSCI 363 Spring 2013
 * By copying the pcap header structures here, we don't have to include
 * pcap.h file here.
 */

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/socket.h>
#include <net/if.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <time.h>

#include <netinet/ether.h>
#include <arpa/inet.h>
#include <string.h>

#define int32 int
#define int16 short

#define uint32 unsigned int
#define uint16 unsigned short

#define MAX_ETH_FRAME_LEN 2000  // maximum Ethernet frame length

/* The following structure is the same as defined in pcap.h */
struct pcap_hdr_s { // Global header for libpcap file
  uint32 magic_number;   /* magic number */
  uint16 version_major;  /* major version number */
  uint16 version_minor;  /* minor version number */
  int32  thiszone;       /* GMT to local correction */
  uint32 sigfigs;        /* accuracy of timestamps */
  uint32 snaplen;        /* max length of captured packets, in octets */
  uint32 network;        /* data link type */
};

/* The following structure is the same as defined in pcap.h */
/*
 * For each Ethernet frame recorded in the trace file you are given,
 * there exists a corresponding header created during the capture of
 * the frame. To be more accurate, the trace file you are given does
 * not contain an entire Ethernet frame, only its header. This file is
 * formatted as a collection of tuples <rechdr, ethhdr>. 
 *
 */
struct pcaprec_hdr_s { // Record (packet) header
  uint32         tv_sec, tv_usec; /* time value when the packet captured */
  uint32         caplen;	/* length of portion captured */
  uint32         len;	        /* length of original packet (off wire) */
};

/* 10Mb/s ethernet header */
struct ether_hdr_s
{
  u_int8_t  ether_dhost[ETH_ALEN];      /* destination eth addr */
  u_int8_t  ether_shost[ETH_ALEN];      /* source ether addr    */
  u_int16_t ether_type;                 /* packet type ID field */
};

/* Ethernet protocol ID's */
#define ETHERTYPE_IP            0x0800          /* IP */
#define ETH_ALEN	6		/* Octets in one ethernet addr	 */

/* ip header file from /usr/include/netinet/ip.h */
struct iphdr
  {
#if __BYTE_ORDER == __LITTLE_ENDIAN
    unsigned int ihl:4;
    unsigned int version:4;
#elif __BYTE_ORDER == __BIG_ENDIAN
    unsigned int version:4;
    unsigned int ihl:4;
#else
# error "Please fix <bits/endian.h>"
#endif
    u_int8_t tos;
    u_int16_t tot_len;
    u_int16_t id;
    u_int16_t frag_off;
    u_int8_t ttl;
    u_int8_t protocol;
    u_int16_t check;
    u_int32_t saddr;
    u_int32_t daddr;
    /*The options start here. */
  };

int main(int argc, char* argv[]){

	struct pcap_hdr_s file_header;
	struct pcaprec_hdr_s frame_header;
	struct ether_hdr_s ether_header;
	struct iphdr ip_header;
	int size_read;
	int count = 0;
	char * buf;

        /* define local variables */
	if(argc != 2){
		printf("USAGE: %s [data filename]\n",argv[0]);
		exit(-1);
	}

        /* open trace data file */
	FILE * fd;
	fd = fopen(argv[1], "r");

        /* read and print file header */
	size_read = fread(&file_header, sizeof(struct pcap_hdr_s), 1, fd);
	
	/* allocate the memory for the 'buf' to store the packet data */
	buf = (char *)malloc(file_header.snaplen);	

	printf("==== GLOBAL HEADER ====\n");
	printf("magic number: %x\n", file_header.magic_number);
	printf("major version %d\n", file_header.version_major);
	printf("minor version %d\n", file_header.version_minor);
	printf("maximum captured packet length %d\n", file_header.snaplen);
	printf("link layer type %d\n", file_header.network);

	/*
	 * while there are tuples to read
	 *
	 *     read next captured frame header
	 *     print captured frame header info (capture time, frame length)
	 *     read next ethernet frame
	 *     extract Ethernet addresses, IP addresses and protocol type
	 *     print information extracted
	 *
	 * end-while
	 *
	 */
	while(0 < (size_read = fread(&frame_header, sizeof(struct pcaprec_hdr_s), 1, fd))){

		/* extract the time stamp */
		long time_val = frame_header.tv_sec;

		printf("\n=== packet count %d ===\n", count);
		printf("time captured %s", ctime((const time_t *)&(time_val)));
		printf("bytes captured %d\n", frame_header.caplen);
		printf("length of packet %d\n", frame_header.len);

		/* read the frame content into 'buf' */
		size_read = fread(buf, frame_header.caplen, 1, fd);
		
		/* get the ethernet frame */
		memcpy(&ether_header, buf, sizeof(struct ether_hdr_s));

		/* fix the endianess of type int */
		u_int16_t type;
		type = ntohs(ether_header.ether_type);
	
		/* check the ethernet type */
		if(ETHERTYPE_IP != type){
			printf("Ethernet type 0x%04x not IP, not processed.\n", type);
		}else{
			/* get the ethernet addresses from ether_header */
			char * dst_addr, * src_addr;
			dst_addr = (char *)malloc(80);
			src_addr = (char *)malloc(80);
			strcpy(dst_addr, ether_ntoa((struct ether_addr *)ether_header.ether_dhost));
			strcpy(src_addr,ether_ntoa((struct ether_addr *)ether_header.ether_shost));

			/* process the ethernet IP frame */
			memcpy(&ip_header, &buf[sizeof(struct ether_hdr_s)], sizeof(struct iphdr));
			char * ip_daddr, * ip_saddr;
			ip_daddr = (char *)malloc(80);
			ip_saddr = (char *)malloc(80);
			ip_daddr = inet_ntop(AF_INET, &ip_header.daddr, ip_daddr, 80);
			ip_saddr = inet_ntop(AF_INET, &ip_header.saddr, ip_saddr, 80);

			/* print the information */
			printf("IP packet length %d\n", ip_header.tot_len);	
			printf("dst addr = %s\n", dst_addr);	
			printf("src addr = %s\n", src_addr);	
			printf("type = 0x%04x\n",type);	
			printf("src IP addr = %s\n", ip_saddr);	
			printf("dst IP addr = %s\n", ip_daddr);	

			/* clean up */
			free(src_addr);
			free(dst_addr);
			free(ip_daddr);
			free(ip_saddr);
		}
		
		count++;
	}

        /* close trace data file */

        return 0;
}
